T: EC2025 + Sortowanie w JS

 - O(n) - [3,4,5,6] 4 operacja
 - O(n^2) - sortowanie bąbelkowe
 - n log n - (dziel i zwyciężaj) quick sort, merge sort 4* log2 4 = 4 * 2 = 8

 Buble sort: 
    [4,3,2,7] O(n^2)
    (1):
    [(4,3),2,7] 3 < 4 -> [3,4,2,7]
    [3,(4,2),7] 2 < 4 -> [3,2,4,7]
    [3,2,(4,7)] 7 > 4 -> [3,2,4,7]
    (2):
    [(3,2),4,7] 2 < 3 -> [2,3,4,7]
    [2,(3,4),7] 4 > 3 -> [2,3,4,7]
    [2,3,(4,7)] 7 > 4 -> [2,3,4,7]
    (3):
    ...
    (4):
    ...

    swap(4,5)
    let temp = 4
    4 = 3
    3 = temp
 Quick sort -> rekurencja:

    [4,3,2,7,1,6,8,5] -> max 24
    [4,3,2,7,1,6,8,(5)]
    pivot = 5
    L[4,3,2,(1)] -> Pivot = 1
        L[]
        P[4,3,(2)] -> Pivot = 2
        L[]
        P[4,(3)] - Pivot = 3
        L[]
        p[4]
    P[7,6,(8)] -> Pivot = 8
        L[7,(6)] -> Pivot = 6
        P[] 
        L[7]
        P[]
    
    QuickSort(tab){
        if(tab.length <= 1){
            tab;
        }
        return(... Quick(L[]),pivot, ... Quick(P[]));
    }
 Merge sort:
    (1) Dzielenie tablicy
    (2) Scalanie 
    [4,3,2,7,1,6,8,5] -> 24
    [4,3,2,7,1,6,8,5] ->[4,3,2,7] i [1,6,8,5] 
        [4,3,2,7] -> [4,3] i [2,7] -> [2,3,4,7]
            [4,3] -> [4] i [3] -> [3,4]
            [2,7] -> [2] i [7] -> [2,7]
        [1,6,8,5] -> [1,6] i [8,5] -> [1,5,6,8]
            [1,6] -> [1] i [6] -> [1,6]
            [8,5] -> [8] i [5] -> [5,8]

    [1,6] + [5,8] -> [1,5,6,8]
    [3,4] + [2,7] -> [2,3,4,7]
    [2,3,4,7] + [1,5,6,8] -> [1,2,3,4,5,6,7,8]
